# -*- coding: utf-8 -*-
"""ResNet 34.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WmgwdqL9daY6CdcCfdGSkLsPpa7MHysu

# Custom Resnet34 for Image Classification in fastai and PyTorch.

# Install fastai dependencies
"""

!pip install fastai

from fastai.vision import *

"""# Our Augmented Dataset on Roboflow."""

'''
from google.colab import drive
drive.mount('/content/gdrive')
'''

!curl -L "https://app.roboflow.com/ds/LwMQMyRCnP?key=Ln9dGe4rpJ" > roboflow.zip; unzip roboflow.zip; rm roboflow.zip

# !curl -L "https://app.roboflow.com/ds/q3Aab8OafY?key=2jgsEJN9Ue" > roboflow.zip; unzip roboflow.zip; rm roboflow.zip

'''
!unzip /content/gdrive/MyDrive/DATASET/train.zip -d augdataset
!unzip /content/gdrive/MyDrive/DATASET/test.zip -d augdataset
!unzip /content/gdrive/MyDrive/DATASET/val.zip -d augdataset
'''

# Build fastai dataset loader.
np.random.seed(42)
path = Path('/content/')
data = ImageDataBunch.from_folder(path, size=224, num_workers=4).normalize(imagenet_stats)

# Check the data classes.
data.classes

# Show Batch Images.
data.show_batch(rows=3, figsize=(7, 8))

"""# Set up fastai Resnet model"""

from fastai.metrics import error_rate
learn = create_cnn(data, models.resnet34, metrics=accuracy)

# Print Network Layers.
learn

"""# Train Custom Resnet Image Classifier"""

from fastai.callbacks import *
early_stop = EarlyStoppingCallback(learn, patience=20)
save_best_model = SaveModelCallback(learn, name='best_resnet34')

defaults.device = torch.device('cuda')
learn.fit_one_cycle(2, callbacks=[early_stop, save_best_model])

# Load Best Model.
learn.load('best_resnet34')

learn.unfreeze()

def find_appropriate_lr(model:Learner, lr_diff:int = 15, loss_threshold:float = .05, adjust_value:float = 1, plot:bool = False) -> float:
    # Run the Learning Rate Finder.
    model.lr_find()
    
    # Get loss values and their corresponding gradients, and get lr values.
    losses = np.array(model.recorder.losses)
    min_loss_index = np.argmin(losses)
    

    lrs = model.recorder.lrs
    
    # Return the Learning Rate that produces the minimum loss divide by 10.   
    return lrs[min_loss_index] / 10

optimal_lr = find_appropriate_lr(learn)

learn.fit_one_cycle(1, max_lr=slice(optimal_lr/10, optimal_lr), callbacks=[early_stop, save_best_model])

learn.load('best_resnet34')

"""# Evaluate Classifier Performance"""

interp = ClassificationInterpretation.from_learner(learn)
interp.plot_confusion_matrix()

interp.plot_top_losses(9, figsize=(15,15))

# Test & Predict.
import glob
from IPython.display import Image, display

model = learn.model
model = model.cuda()
torch.save(model.state_dict(), "/content/resnet34_model.pth")

for imageName in glob.glob('/content/test/*/*.jpg'):
    print(imageName)
    img = open_image(imageName)
    prediction = learn.predict(img)
    print(prediction[0])
    display(Image(filename=imageName))
    print("\n")

"""# Save custom classification model for future use"""

# Commented out IPython magic to ensure Python compatibility.
# %ls models/

from google.colab import files
files.download('./models/best_resnet34.pth')